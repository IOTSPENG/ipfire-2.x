From 0491805d2ff6e7727f0272c94fd97d9897d1e22c Mon Sep 17 00:00:00 2001
From: Simon Kelley <simon@thekelleys.org.uk>
Date: Mon, 26 Jan 2015 11:23:43 +0000
Subject: [PATCH 37/71] Allow inotify to be disabled at compile time on Linux.

---
 CHANGELOG     |  4 +++-
 src/config.h  | 13 ++++++++++++-
 src/dnsmasq.c | 21 +++++++++++++--------
 src/dnsmasq.h | 11 +++++++----
 src/inotify.c |  4 ++--
 5 files changed, 37 insertions(+), 16 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index a4cb901e83ae..c05dec63c587 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -9,7 +9,9 @@ version 2.73
 
 	    Use inotify for checking on updates to /etc/resolv.conf and
 	    friends under Linux. This fixes race conditions when the files are 
-	    updated rapidly and saves CPU by noy polling.
+	    updated rapidly and saves CPU by noy polling. To build
+	    a binary that runs on old Linux kernels without inotify,
+	    use make COPTS=-DNO_INOTIFY
 
 	    Fix breakage of --domain=<domain>,<subnet>,local - only reverse
 	    queries were intercepted. THis appears to have been broken 
diff --git a/src/config.h b/src/config.h
index cdca231b4079..5e5009271eba 100644
--- a/src/config.h
+++ b/src/config.h
@@ -115,6 +115,8 @@ HAVE_DNSSEC
 HAVE_LOOP
    include functionality to probe for and remove DNS forwarding loops.
 
+HAVE_INOTIFY
+   use the Linux inotify facility to efficiently re-read configuration files.
 
 NO_IPV6
 NO_TFTP
@@ -123,6 +125,7 @@ NO_DHCP6
 NO_SCRIPT
 NO_LARGEFILE
 NO_AUTH
+NO_INOTIFY
    these are avilable to explictly disable compile time options which would 
    otherwise be enabled automatically (HAVE_IPV6, >2Gb file sizes) or 
    which are enabled  by default in the distributed source tree. Building dnsmasq
@@ -355,6 +358,10 @@ HAVE_SOCKADDR_SA_LEN
 #undef HAVE_LOOP
 #endif
 
+#if defined (HAVE_LINUX_NETWORK) && !defined(NO_INOTIFY)
+#define HAVE_INOTIFY
+#endif
+
 /* Define a string indicating which options are in use.
    DNSMASQP_COMPILE_OPTS is only defined in dnsmasq.c */
 
@@ -428,7 +435,11 @@ static char *compile_opts =
 #ifndef HAVE_LOOP
 "no-"
 #endif
-"loop-detect";
+"loop-detect "
+#ifndef HAVE_INOTIFY
+"no-"
+#endif
+"inotify";
 
 
 #endif
diff --git a/src/dnsmasq.c b/src/dnsmasq.c
index 04cc98278f62..bc4f47170705 100644
--- a/src/dnsmasq.c
+++ b/src/dnsmasq.c
@@ -142,7 +142,9 @@ int main (int argc, char **argv)
       set_option_bool(OPT_NOWILD);
       reset_option_bool(OPT_CLEVERBIND);
     }
+#endif
 
+#ifndef HAVE_INOTIFY
   if (daemon->inotify_hosts)
     die(_("dhcp-hostsdir not supported on this platform"), NULL, EC_BADCONF);
 #endif
@@ -321,7 +323,7 @@ int main (int argc, char **argv)
 #endif
     }
 
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
   if ((!option_bool(OPT_NO_POLL) && daemon->port != 0) ||
       daemon->dhcp || daemon->doing_dhcp6)
     inotify_dnsmasq_init();
@@ -802,7 +804,7 @@ int main (int argc, char **argv)
   
   pid = getpid();
   
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
   /* Using inotify, have to select a resolv file at startup */
   poll_resolv(1, 0, now);
 #endif
@@ -872,15 +874,18 @@ int main (int argc, char **argv)
 	  bump_maxfd(daemon->icmp6fd, &maxfd); 
 	}
 #endif
-
-#if defined(HAVE_LINUX_NETWORK)
-      FD_SET(daemon->netlinkfd, &rset);
-      bump_maxfd(daemon->netlinkfd, &maxfd);
+    
+#ifdef HAVE_INOTIFY
       if (daemon->inotifyfd != -1)
 	{
 	  FD_SET(daemon->inotifyfd, &rset);
 	  bump_maxfd(daemon->inotifyfd, &maxfd);
 	}
+#endif
+
+#if defined(HAVE_LINUX_NETWORK)
+      FD_SET(daemon->netlinkfd, &rset);
+      bump_maxfd(daemon->netlinkfd, &maxfd);
 #elif defined(HAVE_BSD_NETWORK)
       FD_SET(daemon->routefd, &rset);
       bump_maxfd(daemon->routefd, &maxfd);
@@ -948,7 +953,7 @@ int main (int argc, char **argv)
 	route_sock();
 #endif
 
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
       if  (daemon->inotifyfd != -1 && FD_ISSET(daemon->inotifyfd, &rset) && inotify_check(now))
 	{
 	  if (daemon->port != 0 && !option_bool(OPT_NO_POLL))
@@ -1394,7 +1399,7 @@ void clear_cache_and_reload(time_t now)
       if (option_bool(OPT_ETHERS))
 	dhcp_read_ethers();
       reread_dhcp();
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
       set_dhcp_inotify();
 #endif
       dhcp_update_configs(daemon->dhcp_conf);
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index d841fdc064ad..8091634f69db 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -544,7 +544,7 @@ struct resolvc {
   int is_default, logged;
   time_t mtime;
   char *name;
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
   int wd; /* inotify watch descriptor */
   char *file; /* pointer to file part if path */
 #endif
@@ -558,7 +558,7 @@ struct hostsfile {
   struct hostsfile *next;
   int flags;
   char *fname;
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
   int wd; /* inotify watch descriptor */
 #endif
   unsigned int index; /* matches to cache entries for logging */
@@ -1013,8 +1013,11 @@ extern struct daemon {
 
   /* DHCP state */
   int dhcpfd, helperfd, pxefd; 
+#ifdef HAVE_INOTIFY
+  int inotifyfd;
+#endif
 #if defined(HAVE_LINUX_NETWORK)
-  int netlinkfd, inotifyfd;
+  int netlinkfd;
 #elif defined(HAVE_BSD_NETWORK)
   int dhcp_raw_fd, dhcp_icmp_fd, routefd;
 #endif
@@ -1488,7 +1491,7 @@ int detect_loop(char *query, int type);
 #endif
 
 /* inotify.c */
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
 void inotify_dnsmasq_init();
 int inotify_check(time_t now);
 #  ifdef HAVE_DHCP
diff --git a/src/inotify.c b/src/inotify.c
index 52a30d7f44db..818fe8eddda4 100644
--- a/src/inotify.c
+++ b/src/inotify.c
@@ -15,7 +15,7 @@
 */
 
 #include "dnsmasq.h"
-#ifdef HAVE_LINUX_NETWORK
+#ifdef HAVE_INOTIFY
 
 #include <sys/inotify.h>
 
@@ -216,5 +216,5 @@ static void check_for_dhcp_inotify(struct inotify_event *in, time_t now)
 
 #endif /* DHCP */
 
-#endif  /* LINUX_NETWORK */
+#endif  /* INOTIFY */
   
-- 
2.1.0

